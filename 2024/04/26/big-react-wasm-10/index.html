<!DOCTYPE html>




<html class="theme-next mist" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />


<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />





  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="wasm,react," />










<meta name="description" content="模仿 big-react，使用 Rust 和 WebAssembly，从零实现 React v18 的核心功能。深入理解 React 源码的同时，还锻炼了 Rust 的技能，简直赢麻了！ 代码地址：https://github.com/ParadeTo/big-react-wasm 本文对应 tag：v10   Based on big-react，I am going to implement">
<meta name="keywords" content="wasm,react">
<meta property="og:type" content="article">
<meta property="og:title" content="从零实现 React v18，但 WASM 版 - [10] 实现单节点更新流程">
<meta property="og:url" content="http://www.paradeto.com/2024/04/26/big-react-wasm-10/index.html">
<meta property="og:site_name" content="Ayou">
<meta property="og:description" content="模仿 big-react，使用 Rust 和 WebAssembly，从零实现 React v18 的核心功能。深入理解 React 源码的同时，还锻炼了 Rust 的技能，简直赢麻了！ 代码地址：https://github.com/ParadeTo/big-react-wasm 本文对应 tag：v10   Based on big-react，I am going to implement">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://www.paradeto.com/2024/04/26/big-react-wasm-10/1.png">
<meta property="og:image" content="http://www.paradeto.com/2024/04/26/big-react-wasm-10/2.png">
<meta property="og:image" content="http://www.paradeto.com/2024/04/26/big-react-wasm-10/3.png">
<meta property="og:image" content="http://www.paradeto.com/2024/04/26/big-react-wasm-10/4.png">
<meta property="og:image" content="http://www.paradeto.com/2024/04/26/big-react-wasm-10/5.png">
<meta property="og:image" content="http://www.paradeto.com/2024/04/26/big-react-wasm-10/6.png">
<meta property="og:updated_time" content="2024-05-07T08:43:18.486Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="从零实现 React v18，但 WASM 版 - [10] 实现单节点更新流程">
<meta name="twitter:description" content="模仿 big-react，使用 Rust 和 WebAssembly，从零实现 React v18 的核心功能。深入理解 React 源码的同时，还锻炼了 Rust 的技能，简直赢麻了！ 代码地址：https://github.com/ParadeTo/big-react-wasm 本文对应 tag：v10   Based on big-react，I am going to implement">
<meta name="twitter:image" content="http://www.paradeto.com/2024/04/26/big-react-wasm-10/1.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>







  <link rel="canonical" href="http://www.paradeto.com/2024/04/26/big-react-wasm-10/"/>






  <title>从零实现 React v18，但 WASM 版 - [10] 实现单节点更新流程 | Ayou</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?6a0c6a11d4daa051d62442b432fb279d";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
    
    
      
    

    <div class="container sidebar-position-left page-post-detail">
      <div class="headband"></div>

      <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
        <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Ayou</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Good Good Study, Day Day Up!</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-demo">
          <a href="/demo/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Demo
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/resume" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            About
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
      </header>

      <main id="main" class="main">
        <div class="main-inner">
          <div class="content-wrap">
            <div id="content" class="content">
              

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.paradeto.com/2024/04/26/big-react-wasm-10/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ayou">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ayou">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">从零实现 React v18，但 WASM 版 - [10] 实现单节点更新流程</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2024-04-26T12:05:22+08:00">
                2024-04-26
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/rust/" itemprop="url" rel="index">
                    <span itemprop="name">rust</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <blockquote>
<p>模仿 <a href="https://github.com/BetaSu/big-react" target="_blank" rel="noopener">big-react</a>，使用 Rust 和 WebAssembly，从零实现 React v18 的核心功能。深入理解 React 源码的同时，还锻炼了 Rust 的技能，简直赢麻了！</p>
<p>代码地址：<a href="https://github.com/ParadeTo/big-react-wasm" target="_blank" rel="noopener">https://github.com/ParadeTo/big-react-wasm</a></p>
<p>本文对应 tag：<a href="https://github.com/ParadeTo/big-react-wasm/tree/v10" target="_blank" rel="noopener">v10</a></p>
</blockquote>
<blockquote>
<p>Based on <a href="https://github.com/BetaSu/big-react" target="_blank" rel="noopener">big-react</a>，I am going to implement React v18 core features from scratch using WASM and Rust.</p>
<p>Code Repository：<a href="https://github.com/ParadeTo/big-react-wasm" target="_blank" rel="noopener">https://github.com/ParadeTo/big-react-wasm</a></p>
<p>The tag related to this article：<a href="https://github.com/ParadeTo/big-react-wasm/tree/v10" target="_blank" rel="noopener">v10</a></p>
</blockquote>
<p>上上篇文章末尾说了我们目前还没有完整的实现更新流程，所以这篇文章我们来实现一下。</p>
<p>The previous article mentioned that we haven’t fully implemented the update process yet. So, in this article, we will implement it.</p>
<p>还是用之前的例子：</p>
<p>Let’s continue using the previous example:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [name, setName] = useState(<span class="function"><span class="params">()</span> =&gt;</span> <span class="string">'ayou'</span>)</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    setName(<span class="string">'ayouayou'</span>)</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;Comp&gt;&#123;name&#125;&lt;<span class="regexp">/Comp&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当我们调用 <code>setName(&#39;ayouayou&#39;)</code> 时，会触发更新流程，而 <code>setName</code> 这个方法是在首次渲染的时候在 <code>mount_state</code> 中返回的，该方法会在当前 <code>FiberNode</code> 的 <code>memoized_state</code> 上挂载一个 <code>Hook</code> 节点，如果有多个 Hooks, 会形成一个链表。<code>Hook</code> 节点上有个 <code>update_queue</code>，显而易见，这是个更新队列。还有个 <code>memoized_state</code> 属性，记录当前 <code>Hook</code> 的状态：</p>
<p>When we call <code>setName(&#39;ayouayou&#39;)</code>, it triggers the update process. The <code>setName</code> method is returned in the <code>mount_state</code> during the initial render. This method attaches a <code>Hook</code> node to the <code>memoized_state</code> of the current <code>FiberNode</code>. If there are multiple hooks, they form a linked list. The <code>Hook</code> node has an <code>update_queue</code>, which is clearly an update queue. It also has a <code>memoized_state</code> property that records the current state of the <code>Hook</code>.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">mount_state</span></span>(initial_state: &amp;JsValue) -&gt; <span class="built_in">Result</span>&lt;<span class="built_in">Vec</span>&lt;JsValue&gt;, JsValue&gt; &#123;</span><br><span class="line">  <span class="comment">// Add hook to current FiberNode memoized_state</span></span><br><span class="line">  <span class="keyword">let</span> hook = mount_work_in_progress_hook();</span><br><span class="line">  <span class="keyword">let</span> memoized_state: JsValue;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> initial_state.is_function() &#123;</span><br><span class="line">    memoized_state = initial_state</span><br><span class="line">        .dyn_ref::&lt;Function&gt;()</span><br><span class="line">        .unwrap()</span><br><span class="line">        .call0(&amp;JsValue::null())?;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      memoized_state = initial_state.clone();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  hook.as_ref().unwrap().clone().borrow_mut().memoized_state =</span><br><span class="line">      <span class="literal">Some</span>(MemoizedState::JsValue(memoized_state.clone()));</span><br><span class="line">  <span class="keyword">let</span> queue = create_update_queue();</span><br><span class="line">  hook.as_ref().unwrap().clone().borrow_mut().update_queue = <span class="literal">Some</span>(queue.clone());</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>mount_state</code> 最终会返回 <code>initial_state</code> 和一个函数：</p>
<p><code>mount_state</code> ultimately returns <code>initial_state</code> and a function:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> q_rc = Rc::new(queue.clone());</span><br><span class="line"><span class="keyword">let</span> q_rc_cloned = q_rc.clone();</span><br><span class="line"><span class="keyword">let</span> fiber = <span class="keyword">unsafe</span> &#123;</span><br><span class="line">    CURRENTLY_RENDERING_FIBER.clone().unwrap()</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> closure = Closure::wrap(<span class="built_in">Box</span>::new(<span class="keyword">move</span> |action: &amp;JsValue| <span class="keyword">unsafe</span> &#123;</span><br><span class="line">    dispatch_set_state(</span><br><span class="line">        fiber.clone(),</span><br><span class="line">        (*q_rc_cloned).clone(),</span><br><span class="line">        action,</span><br><span class="line">    )</span><br><span class="line">&#125;) <span class="keyword">as</span> <span class="built_in">Box</span>&lt;dyn <span class="built_in">Fn</span>(&amp;JsValue)&gt;);</span><br><span class="line"><span class="keyword">let</span> function = closure.as_ref().unchecked_ref::&lt;Function&gt;().clone();</span><br><span class="line">closure.forget();</span><br><span class="line"></span><br><span class="line">queue.clone().borrow_mut().dispatch = <span class="literal">Some</span>(function.clone());</span><br><span class="line"></span><br><span class="line"><span class="literal">Ok</span>(<span class="built_in">vec!</span>[memoized_state, function.into()])</span><br></pre></td></tr></table></figure>
<p>这里有点奇怪的是 <code>closure</code> 中的 <code>q_rc_cloned</code>，明明 <code>queue</code> 已经是个 <code>Rc</code> 类型了，为什么还要在外面再包一层 <code>Rc</code>？因为如果把 <code>(*q_rc_cloned).clone()</code> 改成 <code>queue.clone()</code>，会报如下错误：</p>
<p>It’s a bit strange here with <code>q_rc_cloned</code> in the closure. <code>queue</code> is already of type <code>Rc</code>, so why is there an additional layer of <code>Rc</code> on the outside? This is because if we change <code>(*q_rc_cloned).clone()</code> to <code>queue.clone()</code>, it will result in the following error:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">error[E0382]: borrow of moved value: `queue`</span><br><span class="line">   --&gt; packages/react-reconciler/src/fiber_hooks.rs:<span class="number">251</span>:<span class="number">5</span></span><br><span class="line">    |</span><br><span class="line"><span class="number">233</span> |     <span class="keyword">let</span> queue = create_update_queue();</span><br><span class="line">    |         ----- move occurs because `queue` has type `Rc&lt;RefCell&lt;UpdateQueue&gt;&gt;`, which does not implement the `Copy` trait</span><br><span class="line">...</span><br><span class="line"><span class="number">240</span> |     <span class="keyword">let</span> closure = Closure::wrap(<span class="built_in">Box</span>::new(<span class="keyword">move</span> |action: &amp;JsValue| <span class="keyword">unsafe</span> &#123;</span><br><span class="line">    |                                          ----------------------- value moved into closure here</span><br><span class="line">...</span><br><span class="line"><span class="number">243</span> |             queue.clone(),</span><br><span class="line">    |             ----- variable moved due to <span class="keyword">use</span> <span class="keyword">in</span> closure</span><br><span class="line">...</span><br><span class="line"><span class="number">251</span> |     queue.clone().borrow_mut().dispatch = <span class="literal">Some</span>(function.clone());</span><br><span class="line">    |     ^^^^^ value borrowed here after <span class="keyword">move</span></span><br></pre></td></tr></table></figure>
<p>原因在于 <code>queue</code> 的值的所有权已经被 move 进闭包中了，外面不能再继续使用了。那去掉 move 行么？试试看，结果发现会报这个错误：</p>
<p>The reason is that the ownership of the value of <code>queue</code> has already been moved into the closure, so it can no longer be used outside. Can we remove the move? Let’s try, and we find that it results in this error:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">error[E0597]: `queue` does not live long enough</span><br><span class="line">   --&gt; packages/react-reconciler/src/fiber_hooks.rs:<span class="number">243</span>:<span class="number">13</span></span><br><span class="line">    |</span><br><span class="line"><span class="number">240</span> |       <span class="keyword">let</span> closure = Closure::wrap(<span class="built_in">Box</span>::new(|action: &amp;JsValue| <span class="keyword">unsafe</span> &#123;</span><br><span class="line">    |                                   -        ------------------ value captured here</span><br><span class="line">    |  _________________________________|</span><br><span class="line">    | |</span><br><span class="line"><span class="number">241</span> | |         dispatch_set_state(</span><br><span class="line"><span class="number">242</span> | |             fiber.clone(),</span><br><span class="line"><span class="number">243</span> | |             queue.clone(),</span><br><span class="line">    | |             ^^^^^ borrowed value does not live long enough</span><br><span class="line">...   |</span><br><span class="line"><span class="number">246</span> | |         )</span><br><span class="line"><span class="number">247</span> | |     &#125;) <span class="keyword">as</span> <span class="built_in">Box</span>&lt;dyn <span class="built_in">Fn</span>(&amp;JsValue)&gt;);</span><br><span class="line">    | |______- cast requires that `queue` is borrowed <span class="keyword">for</span> `<span class="symbol">'static</span>`</span><br><span class="line">...</span><br><span class="line"><span class="number">254</span> |   &#125;</span><br><span class="line">    |   - `queue` dropped here <span class="keyword">while</span> still borrowed</span><br></pre></td></tr></table></figure>
<p>原因在于，如果不 move 进去，<code>queue</code> 在 <code>mount_state</code> 执行完后就会被回收，而闭包里面却仍然在借用，显然不行。</p>
<p>The reason is that if we don’t move it in, <code>queue</code> will be deallocated after <code>mount_state</code> is executed, but it is still borrowed inside the closure, which is obviously not allowed.</p>
<p>都说 Rust 学习曲线陡峭的原因就在此，大部分时候都在和编译器作斗争。不过 Rust 的理念就是这样，在程序编译时就把大部分的问题给发现出来，这样修复的效率比上线后发现再修复的效率要高得多。而且，Rust 编译器也很智能，给出的问题描述一般都很清晰。</p>
<p>It is often said that the steep learning curve of Rust lies in the fact that you are constantly fighting with the compiler. However, this is the philosophy of Rust: to discover most issues during compilation, which leads to a much higher efficiency in fixing them compared to discovering and fixing them after deployment. Moreover, the Rust compiler is quite intelligent and provides clear problem descriptions.</p>
<p>继续回到使用 move 和 <code>queue</code> 的错误。分析一下，因为 <code>queue</code> 被 move 了，所以后面不能使用 <code>queue</code>，那么如果我们 move 一个别的值不就可以了么，所以就有了 <code>queue_rc</code>，两者的内存模型对比如下所示：</p>
<p>Let’s get back to the error of using move and <code>queue</code>. Analyzing the situation, since <code>queue</code> has been moved, we can’t use <code>queue</code> afterwards. So, if we move some other value, wouldn’t that work? That’s why we have <code>queue_rc</code>, and the memory models of the two are compared as shown below:</p>
<p><img src="/2024/04/26/big-react-wasm-10/1.png" alt=""></p>
<p>还有一个值得说明的地方是，我们把这个闭包函数挂载到了每个 <code>Hook</code> 节点的 <code>queue</code> 的 <code>dispatch</code> 属性上：</p>
<p>Another point worth mentioning is that we attach this closure function to the <code>dispatch</code> property of the <code>queue</code> of each <code>Hook</code> node:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">queue.clone().borrow_mut().dispatch = <span class="literal">Some</span>(function.clone());</span><br></pre></td></tr></table></figure>
<p>是为了在 <code>update_state</code> 时返回同样的函数：</p>
<p>This is done to return the same function during <code>update_state</code>:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">update_state</span></span>(initial_state: &amp;JsValue) -&gt; <span class="built_in">Result</span>&lt;<span class="built_in">Vec</span>&lt;JsValue&gt;, JsValue&gt; &#123;</span><br><span class="line">   ...</span><br><span class="line">    <span class="literal">Ok</span>(<span class="built_in">vec!</span>[</span><br><span class="line">        hook.clone().unwrap().clone()</span><br><span class="line">            .borrow()</span><br><span class="line">            .memoized_state</span><br><span class="line">            .clone()</span><br><span class="line">            .unwrap()</span><br><span class="line">            .js_value()</span><br><span class="line">            .unwrap().clone(),</span><br><span class="line">        queue.clone().unwrap().borrow().dispatch.clone().into(),</span><br><span class="line">    ])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不过我感觉这个 <code>dispatch</code> 作为 <code>Hook</code> 的属性更合适，至少目前来看它跟 <code>queue</code> 好像没什么关联。</p>
<p>However, I feel that having <code>dispatch</code> as an attribute of <code>Hook</code> is more appropriate. At least for now, it doesn’t seem to have any direct association with <code>queue</code>.</p>
<p>回到代码，当调用 <code>dispatch</code> 时，最后会调用 <code>dispatch_set_state</code>：</p>
<p>Returning to the code, when <code>dispatch</code> is called, it eventually invokes <code>dispatch_set_state</code>:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">dispatch_set_state</span></span>(</span><br><span class="line">    fiber: Rc&lt;RefCell&lt;FiberNode&gt;&gt;,</span><br><span class="line">    update_queue: Rc&lt;RefCell&lt;UpdateQueue&gt;&gt;,</span><br><span class="line">    action: &amp;JsValue,</span><br><span class="line">) &#123;</span><br><span class="line">    <span class="keyword">let</span> update = create_update(action.clone());</span><br><span class="line">    enqueue_update(update_queue.clone(), update);</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        WORK_LOOP</span><br><span class="line">            .as_ref()</span><br><span class="line">            .unwrap()</span><br><span class="line">            .clone()</span><br><span class="line">            .borrow()</span><br><span class="line">            .schedule_update_on_fiber(fiber.clone());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它的作用就是使用传入的 <code>action</code> 更新 <code>Hook</code> 节点的 <code>update_queue</code>，并开启一轮新的更新流程，此时 <code>App</code> 节点状态如下图所示：</p>
<p>Its purpose is to update the <code>update_queue</code> of the <code>Hook</code> node with the provided <code>action</code> and initiate a new round of update process. At this point, the state of the <code>App</code> node looks as shown in the following diagram:</p>
<p><img src="/2024/04/26/big-react-wasm-10/2.png" alt=""></p>
<p>接下来流程跟首次渲染类似，首先看 begin work，更新过程的 begin work 主要是对于 <code>FiberNode</code> 的子节点的处理，它通过当前 Fiber Tree 中的子 <code>FiberNode</code> 节点和新产生的 <code>ReactElement</code> （代码中叫做 children）来生成新的子 <code>FiberNode</code>，也就是我们常说的 diff 过程：</p>
<p>Next, the process is similar to the initial rendering. First, let’s look at the “begin work” phase. During the update process, the “begin work” phase primarily handles the child nodes of the <code>FiberNode</code>. It generates new child <code>FiberNode</code> by comparing the existing child <code>FiberNode</code> in the Fiber Tree with the newly generated <code>ReactElement</code> (referred to as <code>children</code> in the code). This is commonly known as the diffing process:</p>
<p><img src="/2024/04/26/big-react-wasm-10/3.png" alt=""></p>
<p>其中，不同类型的 <code>FiberNode</code> 节点产生 children 的方式有所不同：</p>
<ul>
<li><code>HostRoot</code>：从 <code>memoized_state</code> 取值</li>
<li><code>HostComponent</code>：从 <code>pending_props</code> 中取值</li>
<li><code>FunctionComponent</code>：通过执行 <code>type</code> 指向的 <code>Function</code> 来得到</li>
<li><code>HostText</code>：没有这个过程，略</li>
</ul>
<p>The way children are generated differs based on the type of <code>FiberNode</code>:</p>
<ul>
<li><code>HostRoot</code>: Values are taken from <code>memoized_state</code>.</li>
<li><code>HostComponent</code>: Values are taken from <code>pending_props</code>.</li>
<li><code>FunctionComponent</code>: Obtained by executing the <code>Function</code> pointed to by the <code>type</code>.</li>
<li><code>HostText</code>: This process is not applicable and can be ignored.</li>
</ul>
<p>而如何产生这个新的子 <code>FiberNode</code>，也有两种情况：</p>
<p>There are two scenarios for generating these new child <code>FiberNode</code>:</p>
<ul>
<li>Diff 的 <code>ReactElement</code> 和 <code>FiberNode</code> 的 <code>key</code> 和 <code>type</code> 都一样。复用 <code>FiberNode</code>，使用 <code>ReactElement</code> 上的 <code>props</code> 来更新 <code>FiberNode</code> 中的 <code>pending_props</code>：</li>
</ul>
<ul>
<li>When the <code>key</code> and <code>type</code> of the diffing <code>ReactElement</code> and <code>FiberNode</code> are the same. The <code>FiberNode</code> is reused, and the <code>pending_props</code> of the <code>FiberNode</code> are updated with the <code>props</code> from the <code>ReactElement</code>:</li>
</ul>
<p><img src="/2024/04/26/big-react-wasm-10/4.png" alt=""></p>
<ul>
<li>其他情况。创建新的 <code>FiberNode</code>，并在父节点打上 <code>ChildDeletion</code> 标记，同时把旧的 <code>FiberNode</code> 添加到 <code>deletions</code> 列表中：</li>
</ul>
<ul>
<li>In other cases, a new <code>FiberNode</code> is created, and the parent node is marked with the <code>ChildDeletion</code> flag. The old <code>FiberNode</code> is added to the <code>deletions</code> list:</li>
</ul>
<p><img src="/2024/04/26/big-react-wasm-10/5.png" alt=""></p>
<p>代码就不贴了，可以查看<a href="https://github.com/ParadeTo/big-react-wasm/pull/9/files" target="_blank" rel="noopener">本次改动</a>的 <code>child_fiber</code> 文件。</p>
<p>I won’t provide the code here, but you can refer to the <code>child_fiber</code> file in <a href="https://github.com/ParadeTo/big-react-wasm/pull/9/files" target="_blank" rel="noopener">this commit</a>.</p>
<p>由于 <code>FunctionComponent</code> 产生 children 的方式相对复杂一点，我们再回过头来看看 <code>render_with_hooks</code> 方法，主要改动点为：</p>
<p>Since generating children for <code>FunctionComponent</code> is a bit more complex, let’s go back and look at the changes made in the <code>render_with_hooks</code> method. The main changes are:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">render_with_hooks</span></span>(work_in_progress: Rc&lt;RefCell&lt;FiberNode&gt;&gt;) -&gt; <span class="built_in">Result</span>&lt;JsValue, JsValue&gt; &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span> current.is_some() &#123;</span><br><span class="line">      <span class="comment">// log!("还未实现update时renderWithHooks");</span></span><br><span class="line">      update_hooks_to_dispatcher(<span class="literal">true</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      update_hooks_to_dispatcher(<span class="literal">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">update_hooks_to_dispatcher</span></span>(is_update: <span class="built_in">bool</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> object = Object::new();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> closure = Closure::wrap(<span class="built_in">Box</span>::new(<span class="keyword">if</span> is_update &#123; update_state &#125; <span class="keyword">else</span> &#123; mount_state &#125;)</span><br><span class="line">        <span class="keyword">as</span> <span class="built_in">Box</span>&lt;dyn <span class="built_in">Fn</span>(&amp;JsValue) -&gt; <span class="built_in">Result</span>&lt;<span class="built_in">Vec</span>&lt;JsValue&gt;, JsValue&gt;&gt;);</span><br><span class="line">    <span class="keyword">let</span> function = closure.as_ref().unchecked_ref::&lt;Function&gt;().clone();</span><br><span class="line">    closure.forget();</span><br><span class="line">    Reflect::set(&amp;object, &amp;<span class="string">"use_state"</span>.into(), &amp;function).expect(<span class="string">"TODO: panic set use_state"</span>);</span><br><span class="line"></span><br><span class="line">    updateDispatcher(&amp;object.into());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是在更新的时候把 <code>dispatcher</code> 里的 <code>use_state</code> 更新为 <code>update_state</code> 方法，而 <code>update_state</code> 中主要是根据 <code>Hooks</code> 上的 <code>update_queue</code> 和 <code>memoized_state</code> 计算出新的 <code>memoized_state</code> 进行返回，同时还返回了 <code>dispatch</code> 函数：</p>
<p>During the update, the <code>use_state</code> in the <code>dispatcher</code> is replaced with the <code>update_state</code> method. The <code>update_state</code> method primarily calculates the new <code>memoized_state</code> based on the <code>update_queue</code> and <code>memoized_state</code> of the <code>Hooks</code> and returns it. It also returns the <code>dispatch</code> function.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">update_state</span></span>(initial_state: &amp;JsValue) -&gt; <span class="built_in">Result</span>&lt;<span class="built_in">Vec</span>&lt;JsValue&gt;, JsValue&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> hook = update_work_in_progress_hook();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> hook_cloned = hook.clone().unwrap().clone();</span><br><span class="line">    <span class="keyword">let</span> queue = hook_cloned.borrow().update_queue.clone();</span><br><span class="line">    <span class="keyword">let</span> base_state = hook_cloned.borrow().memoized_state.clone();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        hook_cloned.borrow_mut().memoized_state = process_update_queue(</span><br><span class="line">            base_state,</span><br><span class="line">            queue.clone(),</span><br><span class="line">            CURRENTLY_RENDERING_FIBER.clone().unwrap(),</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="literal">Ok</span>(<span class="built_in">vec!</span>[</span><br><span class="line">        hook.clone().unwrap().clone()</span><br><span class="line">            .borrow()</span><br><span class="line">            .memoized_state</span><br><span class="line">            .clone()</span><br><span class="line">            .unwrap()</span><br><span class="line">            .js_value()</span><br><span class="line">            .unwrap().clone(),</span><br><span class="line">        queue.clone().unwrap().borrow().dispatch.clone().into(),</span><br><span class="line">    ])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>begin work 阶段就说这么多，接下来看看 complete work 阶段，complete work 阶段相对来说简单一点，主要是对节点进行 <code>Update</code> 标记，修改了处理 <code>HostText</code> 和 <code>HostComponent</code> 的逻辑：</p>
<p>That’s all for the “begin work” phase. Next, let’s take a look at the “complete work” phase, which is relatively simpler. In this phase, nodes are marked with the <code>Update</code> flag, and the logic for handling <code>HostText</code> and <code>HostComponent</code> is modified.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">WorkTag::HostText =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> current.is_some() &amp;&amp; work_in_progress_cloned.borrow().state_node.is_some() &#123;</span><br><span class="line">      <span class="comment">// reuse FiberNode</span></span><br><span class="line">      <span class="keyword">let</span> old_text = derive_from_js_value(&amp;current.clone().unwrap().clone().borrow().memoized_props, <span class="string">"content"</span>);</span><br><span class="line">      <span class="keyword">let</span> new_test = derive_from_js_value(&amp;new_props, <span class="string">"content"</span>);</span><br><span class="line">      <span class="keyword">if</span> !Object::is(&amp;old_text, &amp;new_test) &#123;</span><br><span class="line">          CompleteWork::mark_update(work_in_progress.clone());</span><br><span class="line">      &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> text_instance = <span class="keyword">self</span>.host_config.create_text_instance(</span><br><span class="line">          Reflect::get(&amp;new_props, &amp;JsValue::from_str(<span class="string">"content"</span>))</span><br><span class="line">              .unwrap()</span><br><span class="line">              .as_string()</span><br><span class="line">              .unwrap(),</span><br><span class="line">      );</span><br><span class="line">      work_in_progress.clone().borrow_mut().state_node =</span><br><span class="line">          <span class="literal">Some</span>(Rc::new(StateNode::Element(text_instance.clone())));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">self</span>.bubble_properties(work_in_progress.clone());</span><br><span class="line">  <span class="literal">None</span></span><br><span class="line">&#125;，</span><br><span class="line">WorkTag::HostComponent =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> current.is_some() &amp;&amp; work_in_progress_cloned.borrow().state_node.is_some() &#123;</span><br><span class="line">    <span class="comment">// reuse FiberNode</span></span><br><span class="line">    log!(<span class="string">"TODO: update properties"</span>)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> instance = <span class="keyword">self</span>.host_config.create_instance(</span><br><span class="line">          work_in_progress</span><br><span class="line">              .clone()</span><br><span class="line">              .borrow()</span><br><span class="line">              ._<span class="keyword">type</span></span><br><span class="line">              .as_ref()</span><br><span class="line">              .as_string()</span><br><span class="line">              .unwrap(),</span><br><span class="line">      );</span><br><span class="line">      <span class="keyword">self</span>.append_all_children(instance.clone(), work_in_progress.clone());</span><br><span class="line">      work_in_progress.clone().borrow_mut().state_node =</span><br><span class="line">          <span class="literal">Some</span>(Rc::new(StateNode::Element(instance.clone())));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">self</span>.bubble_properties(work_in_progress.clone());</span><br><span class="line">  <span class="literal">None</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后是 commit 阶段，主要就是在 <code>commit_mutation_effects_on_fiber</code> 中增加对 <code>Update</code> 和 <code>ChildDeletion</code> 的处理：</p>
<p>Finally, we have the “commit” phase, which mainly involves adding handling for <code>Update</code> and <code>ChildDeletion</code> in the <code>commit_mutation_effects_on_fiber</code> function.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">commit_mutation_effects_on_fiber</span></span>(&amp;<span class="keyword">self</span>, finished_work: Rc&lt;RefCell&lt;FiberNode&gt;&gt;) &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span> flags.contains(Flags::ChildDeletion) &#123;</span><br><span class="line">      <span class="keyword">let</span> deletions = finished_work.clone().borrow().deletions.clone();</span><br><span class="line">      <span class="keyword">if</span> deletions.is_some() &#123;</span><br><span class="line">          <span class="keyword">let</span> deletions = deletions.unwrap();</span><br><span class="line">          <span class="keyword">for</span> child_to_delete <span class="keyword">in</span> deletions &#123;</span><br><span class="line">              <span class="keyword">self</span>.commit_deletion(child_to_delete);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      finished_work.clone().borrow_mut().flags -= Flags::ChildDeletion;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> flags.contains(Flags::Update) &#123;</span><br><span class="line">      <span class="keyword">self</span>.commit_update(finished_work.clone());</span><br><span class="line">      finished_work.clone().borrow_mut().flags -= Flags::Update;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>
<p><code>Update</code> 中目前只处理了 <code>HostText</code>，比较简单，就不介绍了，直接看代码吧，这里重点介绍下 <code>ChildDeletion</code>。</p>
<p>In the <code>Update</code> part, only <code>HostText</code> is currently handled, which is relatively simple, so we won’t go into detail. Let’s directly look at the code. Here, I’ll focus on explaining <code>ChildDeletion</code>.</p>
<p>begin work 中我们说过标记为删除的子节点会被加入父节点的 <code>deletions</code> 列表中，所以这里会遍历这个列表，然后调用 <code>commit_deletion</code>，该函数会采取前序的方式遍历（优先遍历根节点） <code>child_to_delete</code> 为根节点的子树，并执行这些节点上相关的副作用，如：执行 <code>componentWillUnmount</code> 方法或 <code>useEffect</code> 返回的 <code>destroy</code> 方法，从这里也可以发现父组件的副作用会先执行。</p>
<p>In the “begin work” phase, we mentioned that child nodes marked for deletion are added to the <code>deletions</code> list of their parent node. So here, we iterate over this list and call <code>commit_deletion</code>. This function traverses the subtree rooted at <code>child_to_delete</code> in a pre-order manner (prioritizing the traversal of the root node). It executes the relevant side effects on these nodes, such as invoking the <code>componentWillUnmount</code> method or the <code>destroy</code> method returned by <code>useEffect</code>. From this, we can observe that the side effects of the parent component are executed first.</p>
<p>比如下面这个例子：</p>
<p>For example, consider the following example:</p>
<p><img src="/2024/04/26/big-react-wasm-10/6.png" alt=""></p>
<p>的遍历顺序为 <code>div-&gt;p-&gt;i-&gt;span</code>。同时还会记录第一个遍历到的节点，此例为 <code>div</code>，然后在该节点上执行删除操作。</p>
<p>The traversal order is <code>div -&gt; p -&gt; i -&gt; span</code>. Additionally, the first node encountered during traversal is recorded, which in this case is <code>div</code>. The deletion operation is then performed on this node.</p>
<p>好了，单节点更新流程就实现完毕了，简单总结下就是：</p>
<p>Alright, the single-node update process is now complete. In summary:</p>
<ul>
<li>在 begin work 阶段中标记子节点的删除、插入</li>
<li>complete work 阶段中标记节点的更新</li>
<li><p>commit 流程中深度优先遍历 Fiber Tree，处理有标记的节点。对于标记为 <code>ChildDeletion</code> 的节点，会采用前序遍历的方式遍历以此节点为根节点的子树。</p>
</li>
<li><p>In the “begin work” phase, mark child nodes for deletion or insertion.</p>
</li>
<li>In the “complete work” phase, mark nodes for update.</li>
<li>In the commit phase, perform a depth-first traversal of the Fiber Tree, processing the marked nodes. For nodes marked as <code>ChildDeletion</code>, a pre-order traversal is performed on the subtree rooted at that node.</li>
</ul>
<p>更多详见本次<a href="https://github.com/ParadeTo/big-react-wasm/pull/9" target="_blank" rel="noopener">更新</a>。</p>
<p>For more details, please refer to this <a href="https://github.com/ParadeTo/big-react-wasm/pull/9" target="_blank" rel="noopener">update</a>.</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/wasm/" rel="tag"># wasm</a>
          
            <a href="/tags/react/" rel="tag"># react</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2024/04/23/big-react-wasm-9/" rel="next" title="从零实现 React v18，但 WASM 版 - [9] 使用 Jest 进行单元测试">
                <i class="fa fa-chevron-left"></i> 从零实现 React v18，但 WASM 版 - [9] 使用 Jest 进行单元测试
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2024/04/30/big-react-wasm-11/" rel="prev" title="从零实现 React v18，但 WASM 版 - [11] 实现事件系统">
                从零实现 React v18，但 WASM 版 - [11] 实现事件系统 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


            </div>
            


            

  
    <div class="comments" id="comments">
      <div id="lv-container" data-id="city" data-uid="MTAyMC8zODAwNS8xNDUzNQ=="></div>
    </div>

  



          </div>
          
            
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Ayou</p>
              <p class="site-description motion-element" itemprop="description">一名转行的菜鸡程序员</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">182</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">19</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">83</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


          
        </div>
      </main>

      <footer id="footer" class="footer">
        <div class="footer-inner">
          <div class="copyright">&copy; <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Ayou</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>




          







          
        </div>
      </footer>

      
        <div class="back-to-top">
          <i class="fa fa-arrow-up"></i>
          
        </div>
      

      
    
  
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  
    <script type="text/javascript">
      (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
      })(document, 'script');
    </script>
  












  





  

  

  

  
  

  

  

  

  
</body>
</html>
