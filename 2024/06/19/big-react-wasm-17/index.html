<!DOCTYPE html>




<html class="theme-next mist" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />


<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />





  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="wasm,react," />










<meta name="description" content="模仿 big-react，使用 Rust 和 WebAssembly，从零实现 React v18 的核心功能。深入理解 React 源码的同时，还锻炼了 Rust 的技能，简直赢麻了！ 代码地址：https://github.com/ParadeTo/big-react-wasm 本文对应 tag：v17   Based on big-react，I am going to implement">
<meta name="keywords" content="wasm,react">
<meta property="og:type" content="article">
<meta property="og:title" content="从零实现 React v18，但 WASM 版 - [17] 实现 Concurrent 模式">
<meta property="og:url" content="http://www.paradeto.com/2024/06/19/big-react-wasm-17/index.html">
<meta property="og:site_name" content="Ayou">
<meta property="og:description" content="模仿 big-react，使用 Rust 和 WebAssembly，从零实现 React v18 的核心功能。深入理解 React 源码的同时，还锻炼了 Rust 的技能，简直赢麻了！ 代码地址：https://github.com/ParadeTo/big-react-wasm 本文对应 tag：v17   Based on big-react，I am going to implement">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://www.paradeto.com/2024/06/19/big-react-wasm-17/1.png">
<meta property="og:updated_time" content="2024-06-21T01:55:31.696Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="从零实现 React v18，但 WASM 版 - [17] 实现 Concurrent 模式">
<meta name="twitter:description" content="模仿 big-react，使用 Rust 和 WebAssembly，从零实现 React v18 的核心功能。深入理解 React 源码的同时，还锻炼了 Rust 的技能，简直赢麻了！ 代码地址：https://github.com/ParadeTo/big-react-wasm 本文对应 tag：v17   Based on big-react，I am going to implement">
<meta name="twitter:image" content="http://www.paradeto.com/2024/06/19/big-react-wasm-17/1.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>









  <link rel="canonical" href="http://www.paradeto.com/2024/06/19/big-react-wasm-17/"/>






  <title>从零实现 React v18，但 WASM 版 - [17] 实现 Concurrent 模式 | Ayou</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?6a0c6a11d4daa051d62442b432fb279d";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
    
    
      
    

    <div class="container sidebar-position-left page-post-detail">
      <div class="headband"></div>

      <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
        <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Ayou</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Good Good Study, Day Day Up!</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-demo">
          <a href="/demo/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Demo
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/resume" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            About
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
      </header>

      <main id="main" class="main">
        <div class="main-inner">
          <div class="content-wrap">
            <div id="content" class="content">
              

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.paradeto.com/2024/06/19/big-react-wasm-17/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ayou">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ayou">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">从零实现 React v18，但 WASM 版 - [17] 实现 Concurrent 模式</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2024-06-19T17:39:13+08:00">
                2024-06-19
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/rust/" itemprop="url" rel="index">
                    <span itemprop="name">rust</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <blockquote>
<p>模仿 <a href="https://github.com/BetaSu/big-react" target="_blank" rel="noopener">big-react</a>，使用 Rust 和 WebAssembly，从零实现 React v18 的核心功能。深入理解 React 源码的同时，还锻炼了 Rust 的技能，简直赢麻了！</p>
<p>代码地址：<a href="https://github.com/ParadeTo/big-react-wasm" target="_blank" rel="noopener">https://github.com/ParadeTo/big-react-wasm</a></p>
<p>本文对应 tag：<a href="https://github.com/ParadeTo/big-react-wasm/tree/v17" target="_blank" rel="noopener">v17</a></p>
</blockquote>
<blockquote>
<p>Based on <a href="https://github.com/BetaSu/big-react" target="_blank" rel="noopener">big-react</a>，I am going to implement React v18 core features from scratch using WASM and Rust.</p>
<p>Code Repository：<a href="https://github.com/ParadeTo/big-react-wasm" target="_blank" rel="noopener">https://github.com/ParadeTo/big-react-wasm</a></p>
<p>The tag related to this article：<a href="https://github.com/ParadeTo/big-react-wasm/tree/v17" target="_blank" rel="noopener">v17</a></p>
</blockquote>
<p>React v18 最大卖点之一就是 Concurrent 模式，接下来我们以 Time Slicing 这个功能为切入点来尝试实现一下。对时间切片不熟悉的可以先看一下<a href="/2020/12/30/react-concurrent-1/">这篇文章</a>。</p>
<p>One of the biggest selling points of React v18 is Concurrent mode. Next, let’s try to implement Time Slicing as an entry point. If you’re not familiar with Time Slicing, you can read this article first: <a href="/2020/12/30/react-concurrent-1/">link</a>.</p>
<p>改动最大的部分还是 reconciler 库的 <code>work_loop.rs</code>，先回顾下之前的流程：</p>
<p>The biggest changes are in the <code>work_loop.rs</code> file of the reconciler library. Let’s review the previous flow:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">schedule_update_on_fiber -&gt; ensure_root_is_scheduled -&gt; perform_sync_work_on_root -&gt; work_loop -&gt; commit_root</span><br></pre></td></tr></table></figure>
<p>现在需要改成这样：</p>
<p>Now it needs to be changed to:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">schedule_update_on_fiber -&gt; ensure_root_is_scheduled -&gt; perform_sync_work_on_root -&gt; render_root -&gt; work_loop_sync -&gt; commit_root</span><br><span class="line">                                     |                                                  ^   |                            ^</span><br><span class="line">                                     | ---&gt;   perform_concurrent_work_on_root ----------|   |---&gt; work_loop_concurrent --|</span><br></pre></td></tr></table></figure>
<p>也是就增加了一条 Concurrent 模式的支线，另外增加了 <code>render_root</code>，这样 Render 和 Commit 两大过程也更直观了。</p>
<p>This adds a new branch for the Concurrent mode and introduces the <code>render_root</code> function, making the Render and Commit processes more intuitive.</p>
<p>其中 <code>perform_concurrent_work_on_root</code> 需要使用之前实现的 <code>scheduler</code> 来进行调度：</p>
<p>The <code>perform_concurrent_work_on_root</code> function needs to use the previously implemented <code>scheduler</code> to schedule the work:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> scheduler_priority = lanes_to_scheduler_priority(cur_priority.clone());</span><br><span class="line"><span class="keyword">let</span> closure = Closure::wrap(<span class="built_in">Box</span>::new(<span class="keyword">move</span> |did_timeout_js_value: JsValue| &#123;</span><br><span class="line">    <span class="keyword">let</span> did_timeout = did_timeout_js_value.as_bool().unwrap();</span><br><span class="line">    perform_concurrent_work_on_root(root_cloned.clone(), did_timeout)</span><br><span class="line">&#125;) <span class="keyword">as</span> <span class="built_in">Box</span>&lt;dyn <span class="built_in">Fn</span>(JsValue) -&gt; JsValue&gt;);</span><br><span class="line"><span class="keyword">let</span> function = closure.as_ref().unchecked_ref::&lt;Function&gt;().clone();</span><br><span class="line">closure.forget();</span><br><span class="line">new_callback_node = <span class="literal">Some</span>(unstable_schedule_callback_no_delay(</span><br><span class="line">    scheduler_priority,</span><br><span class="line">    function,</span><br><span class="line">))</span><br></pre></td></tr></table></figure>
<p>而在 <code>perform_concurrent_work_on_root</code> 中，我们需要根据 Render 阶段结束时的返回状态来判断，Render 工作是否完成。</p>
<p>In the <code>perform_concurrent_work_on_root</code> function, we need to check the return status at the end of the Render phase to determine if the Render work is complete.</p>
<p>如果返回状态为 <code>ROOT_INCOMPLETE</code>，说明没完成，也就是时间切片用完了，Render 工作暂时停止，此时需要再次返回一个函数：</p>
<p>If the return status is <code>ROOT_INCOMPLETE</code>, it means that the work is not complete, and the Render work is temporarily paused because the time slice has been used up. In this case, we need to return a function again:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> exit_status = render_root(root.clone(), lanes.clone(), should_time_slice);</span><br><span class="line"><span class="keyword">if</span> exit_status == ROOT_INCOMPLETE &#123;</span><br><span class="line">    <span class="keyword">let</span> root_cloned = root.clone();</span><br><span class="line">    <span class="keyword">let</span> closure = Closure::wrap(<span class="built_in">Box</span>::new(<span class="keyword">move</span> |did_timeout_js_value: JsValue| &#123;</span><br><span class="line">        <span class="keyword">let</span> did_timeout = did_timeout_js_value.as_bool().unwrap();</span><br><span class="line">        perform_concurrent_work_on_root(root_cloned.clone(), did_timeout)</span><br><span class="line">    &#125;) <span class="keyword">as</span> <span class="built_in">Box</span>&lt;dyn <span class="built_in">Fn</span>(JsValue) -&gt; JsValue&gt;);</span><br><span class="line">    <span class="keyword">let</span> function = closure.as_ref().unchecked_ref::&lt;Function&gt;().clone();</span><br><span class="line">    closure.forget();</span><br><span class="line">    <span class="keyword">return</span> function.into();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为 <code>scheduler</code> 有这样的特性，比如下面这个例子：</p>
<p>Because the <code>scheduler</code> has a feature like this, for example:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Scheduler <span class="keyword">from</span> <span class="string">'react/packages/scheduler'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func2</span>(<span class="params">didTimeout</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!didTimeout) <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">  <span class="keyword">return</span> func2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> task = Scheduler.unstable_scheduleCallback(<span class="number">1</span>, func1)</span><br></pre></td></tr></table></figure>
<p><code>func1</code> 结束后返回了 <code>func2</code> 则两个函数会共用 <code>task</code> 的过期时间。</p>
<p>什么意思呢？比如 <code>task</code> 的过期时间是 3 秒，<code>func1</code> 执行用了 2 秒，那么执行到 <code>func2</code> 时，<code>task</code> 还未过期，<code>didTimeout</code> 为 <code>false</code>。<br>如果 <code>func1</code> 执行用了 4 秒，那么执行到 <code>func2</code> 时，<code>task</code> 已过期，<code>didTimeout</code> 为 <code>true</code>。</p>
<p>否则，如果返回状态为 <code>ROOT_COMPLETED</code>，则说明 Render 流程已完全完成，则进行 Commit 流程，这个与之前就是一样的了。</p>
<p>接下来看看 <code>render_root</code>，该方法新增了一个参数 <code>should_time_slice</code>，如果为 <code>true</code> 就调用 <code>work_loop_concurrent</code> 方法，否则调用 <code>work_loop_sync</code> 方法：</p>
<p>When <code>func1</code> finishes and returns <code>func2</code>, both functions will share the expiration time of <code>task</code>.</p>
<p>What does this mean? For example, if the expiration time of <code>task</code> is 3 seconds and <code>func1</code> takes 2 seconds to execute, when <code>func2</code> is executed, <code>task</code> has not expired yet, and <code>didTimeout</code> is <code>false</code>. If <code>func1</code> takes 4 seconds to execute, when <code>func2</code> is executed, <code>task</code> has expired, and <code>didTimeout</code> is <code>true</code>.</p>
<p>Otherwise, if the return status is <code>ROOT_COMPLETED</code>, it means that the Render process has been fully completed, and the Commit process is performed as before.</p>
<p>Next, let’s take a look at the <code>render_root</code> function. It adds a new parameter <code>should_time_slice</code>, and if it’s <code>true</code>, it calls the <code>work_loop_concurrent</code> function; otherwise, it calls the <code>work_loop_sync</code> function:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">loop</span> &#123;</span><br><span class="line">    <span class="keyword">match</span> <span class="keyword">if</span> should_time_slice &#123;</span><br><span class="line">        work_loop_concurrent()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        work_loop_sync()</span><br><span class="line">    &#125; &#123;</span><br><span class="line">        <span class="literal">Ok</span>(_) =&gt; &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="literal">Err</span>(e) =&gt; <span class="keyword">unsafe</span> &#123;</span><br><span class="line">            log!(<span class="string">"work_loop error &#123;:?&#125;"</span>, e);</span><br><span class="line">            WORK_IN_PROGRESS = <span class="literal">None</span></span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中 <code>work_loop_concurrent</code> 与 <code>work_loop_sync</code> 不同之处仅在于增加了 <code>unstable_should_yield_to_host</code> 的约束，即判断时间切片是否已用完：</p>
<p>The only difference between <code>work_loop_concurrent</code> and <code>work_loop_sync</code> is the addition of the constraint <code>unstable_should_yield_to_host</code>, which checks if the time slice has been used up:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">work_loop_concurrent</span></span>() -&gt; <span class="built_in">Result</span>&lt;(), JsValue&gt; &#123;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> WORK_IN_PROGRESS.is_some() &amp;&amp; !unstable_should_yield_to_host() &#123;</span><br><span class="line">            log!(<span class="string">"work_loop_concurrent"</span>);</span><br><span class="line">            perform_unit_of_work(WORK_IN_PROGRESS.clone().unwrap())?;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="literal">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当跳出循环时，如果 <code>should_time_slice</code> 为 <code>true</code> 且 <code>WORK_IN_PROGRESS</code> 不为空，说明 Render 阶段还未完成，此时 <code>render_root</code> 返回 <code>ROOT_INCOMPLETE</code>：</p>
<p>When the loop is exited, if <code>should_time_slice</code> is <code>true</code> and <code>WORK_IN_PROGRESS</code> is not empty, it means that the Render phase is not yet complete. In this case, <code>render_root</code> returns <code>ROOT_INCOMPLETE</code>:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsafe</span> &#123;</span><br><span class="line">    EXECUTION_CONTEXT = prev_execution_context;</span><br><span class="line">    WORK_IN_PROGRESS_ROOT_RENDER_LANE = Lane::NoLane;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> should_time_slice &amp;&amp; WORK_IN_PROGRESS.is_some() &#123;</span><br><span class="line">        <span class="keyword">return</span> ROOT_INCOMPLETE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，整个流程就串起来了。</p>
<p>那什么时候需要使用 Concurrent 模式呢？这个取决于更新的优先级，一般来说，不那么紧急的更新可以使用 Concurrent 模式。</p>
<p>big-react 中目前是这么规定的：</p>
<p>This connects the entire process.</p>
<p>When should we use Concurrent mode? It depends on the priority of the update. Generally, less urgent updates can use Concurrent mode.</p>
<p>In big-react, the current rule is as follows:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> eventTypeToEventPriority = <span class="function">(<span class="params">eventType: string</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> (eventType) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'click'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'keydown'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'keyup'</span>:</span><br><span class="line">      <span class="keyword">return</span> SyncLane</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'scroll'</span>:</span><br><span class="line">      <span class="keyword">return</span> InputContinuousLane</span><br><span class="line">    <span class="comment">// TODO 更多事件类型</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> DefaultLane</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在调用事件的回调函数之前会将 <code>scheduler</code> 中的全局变量 <code>currentPriorityLevel</code> 改成对应的值：</p>
<p>Before calling the event callback function, the global variable <code>currentPriorityLevel</code> in the <code>scheduler</code> is changed to the corresponding value:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// react-dom</span></span><br><span class="line"><span class="keyword">const</span> triggerEventFlow = <span class="function">(<span class="params">paths: EventCallback[], se: SyntheticEvent</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; paths.length; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> callback = paths[i]</span><br><span class="line">    runWithPriority(eventTypeToEventPriority(se.type), () =&gt; &#123;</span><br><span class="line">      callback.call(<span class="literal">null</span>, se)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (se.__stopPropagation) &#123;</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// scheduler</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unstable_runWithPriority</span>(<span class="params">priorityLevel, eventHandler</span>) </span>&#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> previousPriorityLevel = currentPriorityLevel</span><br><span class="line">  currentPriorityLevel = priorityLevel</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> eventHandler()</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    currentPriorityLevel = previousPriorityLevel</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不过，他这里貌似有点小问题，<code>eventTypeToEventPriority</code> 返回的是 Lane，需要转换为 <code>scheduler</code> 中的 Priority 才行，所以我这里做了下修改：</p>
<p>However, there seems to be a small problem here. <code>eventTypeToEventPriority</code> returns Lane, but it needs to be converted to the Priority in the <code>scheduler</code>. So I made some modifications here:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">event_type_to_event_priority</span></span>(event_type: &amp;<span class="built_in">str</span>) -&gt; Priority &#123;</span><br><span class="line">    <span class="keyword">let</span> lane = <span class="keyword">match</span> event_type &#123;</span><br><span class="line">        <span class="string">"click"</span> | <span class="string">"keydown"</span> | <span class="string">"keyup"</span> =&gt; Lane::SyncLane,</span><br><span class="line">        <span class="string">"scroll"</span> =&gt; Lane::InputContinuousLane,</span><br><span class="line">        _ =&gt; Lane::DefaultLane,</span><br><span class="line">    &#125;;</span><br><span class="line">    lanes_to_scheduler_priority(lane)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是这里只是更新了 <code>scheduler</code> 中的 Priority 而已，我们还需要更新 <code>reconciler</code> 中的 Lane，这个是怎么实现的呢？</p>
<p>答案就在 <code>fiber_hooks</code>。<code>useState</code> 返回的第二个值是个函数，当它被调用时，会执行下面这个方法：</p>
<p>But changing the Priority in the <code>scheduler</code> is not enough. We also need to update the Lane in the <code>reconciler</code>. How is this implemented?</p>
<p>The answer lies in <code>fiber_hooks</code>. When the second value returned by <code>useState</code> is called, the following method is executed:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">dispatch_set_state</span></span>(</span><br><span class="line">    fiber: Rc&lt;RefCell&lt;FiberNode&gt;&gt;,</span><br><span class="line">    update_queue: Rc&lt;RefCell&lt;UpdateQueue&gt;&gt;,</span><br><span class="line">    action: &amp;JsValue,</span><br><span class="line">) &#123;</span><br><span class="line">    <span class="keyword">let</span> lane = request_update_lane();</span><br><span class="line">    <span class="keyword">let</span> update = create_update(action.clone(), lane.clone());</span><br><span class="line">    enqueue_update(update_queue.clone(), update);</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        schedule_update_on_fiber(fiber.clone(), lane);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里有个 <code>request_update_lane</code>，它的作用就是根据 <code>scheduler</code> 中的 Priority 来得到对应的 Lane：</p>
<p>There is a <code>request_update_lane</code>, which obtains the corresponding Lane based on the Priority in the <code>scheduler</code>:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">request_update_lane</span></span>() -&gt; Lane &#123;</span><br><span class="line">    <span class="keyword">let</span> current_scheduler_priority_level = unstable_get_current_priority_level();</span><br><span class="line">    <span class="keyword">let</span> update_lane = scheduler_priority_to_lane(current_scheduler_priority_level);</span><br><span class="line">    update_lane</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，当我们触发事件时，就可以将 <code>scheduler</code> 中的 Priority 和当次更新的 Lane 都修改成对应的值了。</p>
<p>一切就绪，我们来测试一下，为了方便，我暂时将 <code>click</code> 的优先级改低一点：</p>
<p>In this way, when we trigger an event, we can change both the Priority in the <code>scheduler</code> and the Lane of the current update to the corresponding values.</p>
<p>Everything is ready. Let’s test it. For convenience, I temporarily lowered the priority of <code>click</code>:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">event_type_to_event_priority</span></span>(event_type: &amp;<span class="built_in">str</span>) -&gt; Priority &#123;</span><br><span class="line">    <span class="keyword">let</span> lane = <span class="keyword">match</span> event_type &#123;</span><br><span class="line">        <span class="string">"click"</span> | <span class="string">"keydown"</span> | <span class="string">"keyup"</span> =&gt; Lane::InputContinuousLane,</span><br><span class="line">        <span class="string">"scroll"</span> =&gt; Lane::InputContinuousLane,</span><br><span class="line">        _ =&gt; Lane::DefaultLane,</span><br><span class="line">    &#125;;</span><br><span class="line">    lanes_to_scheduler_priority(lane)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后用下面这个例子：</p>
<p>Then use the following example:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;useState&#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [num, updateNum] = useState(<span class="number">0</span>)</span><br><span class="line">  <span class="keyword">const</span> len = <span class="number">100</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;ul</span><br><span class="line">      onClick=&#123;(e) =&gt; &#123;</span><br><span class="line">        updateNum(<span class="function">(<span class="params">num: number</span>) =&gt;</span> num + <span class="number">1</span>)</span><br><span class="line">      &#125;&#125;&gt;</span><br><span class="line">      &#123;<span class="built_in">Array</span>(len)</span><br><span class="line">        .fill(<span class="number">1</span>)</span><br><span class="line">        .map(<span class="function">(<span class="params">_, i</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Child</span> <span class="attr">i</span>=<span class="string">&#123;</span>`$&#123;<span class="attr">i</span>&#125; $&#123;<span class="attr">num</span>&#125;`&#125; /&gt;</span></span></span><br><span class="line"><span class="xml">        &#125;)&#125;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">&#123;i&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>i am child &#123;i&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App</span><br></pre></td></tr></table></figure>
<p>运行后可以得到如下结果：</p>
<p>After running, you can get the following result:</p>
<p><img src="/2024/06/19/big-react-wasm-17/1.png" alt=""></p>
<p>其中左边这一部分是首次渲染，没有开启时间切片，右边是点击后的更新，可以看到有很多小的 Task，证明我们的时间切片功能成功实现了。</p>
<p>此次更新代码可以查看<a href="https://github.com/ParadeTo/big-react-wasm/pull/16" target="_blank" rel="noopener">这里</a>。</p>
<p>The left part is the initial render without time slicing, and the right part is the update after clicking. You can see many small tasks, proving that our time slicing feature has been successfully implemented.</p>
<p>You can check out the updated code here.</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/wasm/" rel="tag"># wasm</a>
          
            <a href="/tags/react/" rel="tag"># react</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2024/06/06/big-react-wasm-16/" rel="next" title="从零实现 React v18，但 WASM 版 - [16] 实现 React Noop">
                <i class="fa fa-chevron-left"></i> 从零实现 React v18，但 WASM 版 - [16] 实现 React Noop
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2024/07/10/big-react-wasm-18/" rel="prev" title="从零实现 React v18，但 WASM 版 - [18] 实现 useRef, useCallback, useMemo">
                从零实现 React v18，但 WASM 版 - [18] 实现 useRef, useCallback, useMemo <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


            </div>
            


            

  
    <div class="comments" id="comments">
      <div id="lv-container" data-id="city" data-uid="MTAyMC8zODAwNS8xNDUzNQ=="></div>
    </div>

  



          </div>
          
            
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Ayou</p>
              <p class="site-description motion-element" itemprop="description">一名转行的菜鸡程序员</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">194</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">19</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">83</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


          
        </div>
      </main>

      <footer id="footer" class="footer">
        <div class="footer-inner">
          <div class="copyright">&copy; <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Ayou</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>




          







          
        </div>
      </footer>

      
        <div class="back-to-top">
          <i class="fa fa-arrow-up"></i>
          
        </div>
      

      
    
  
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  
    <script type="text/javascript">
      (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
      })(document, 'script');
    </script>
  












  





  

  

  

  
  

  

  

  

  
</body>
</html>
